<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
</head>
<body>
<h1>Introduction<br>
</h1>
ParserLib is a simple c++ PEG parser. Its aim is to be very simple in
use. <br>
<h1>Grammars</h1>
Grammars can be written in pseudo-EBNF form, as in <a
 href="http://boost-spirit.com/home/">Boost::Spirit</a>, like this:<br>
<pre style="color: rgb(51, 51, 255);">//calculator grammar.<br>extern rule expression;<br>rule whitespace = *term(' ');<br>rule digit = set("0123456789");<br>rule integer = term(+digit);<br>rule num_expression = integer | '(' &gt;&gt; expression &gt;&gt; ')';<br>rule mul_expression = num_expression &gt;&gt; ('*' &gt;&gt; add_expression | '/' &gt;&gt; add_expression);<br>rule add_expression = mul_expression &gt;&gt; ('+' &gt;&gt; add_expression | '-' &gt;&gt; add_expression);<br>rule expression = add_expression;<br></pre>
<h1>Parsing</h1>
Parsing can then be achieved by this piece of code:<br>
<pre><span style="color: rgb(51, 51, 255);">ErrorList errors;</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">AST *ast = parse("1 + (2 * 3)", expression, whitespace, errors);</span><br></pre>
<h1>AST</h1>
The result of the above code, should there be no errors, should be an
AST instance. The AST instance itself is linked with a rule, and has
children. Each parsed element in the grammar gets an AST node. There
are two kinds of AST nodes, non-terminals and terminals. Processing an
AST tree can then be as simple as the following function:<br>
<pre><span style="color: rgb(51, 51, 255);">void process_AST(AST *ast) {</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">    NonTermAST *nonTerm;</span><br
 style="color: rgb(51, 51, 255);"><br style="color: rgb(51, 51, 255);"><span
 style="color: rgb(51, 51, 255);">    switch (ast-&gt;type()) {</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        case NON_TERMINAL:</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            if (ast-&gt;is_rule(num_expression)) {</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">                print("integer found\n");</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            }</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            else if (ast-&gt;is_rule(mul_expression)) {</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">                print("multiplication found\n");</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            }</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            else if (ast-&gt;is_rule(add_expression)) {</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">                print("addition found\n");</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            }</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            nonTerm = (NonTermAST *)ast;</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            for(ASTContainer::const_iterator it = nonTerm-&gt;children().begin();</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">                it != nonTerm-&gt;children().end();</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">                ++it)</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            {</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">                process_AST(*it);</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            }</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            break;</span><br
 style="color: rgb(51, 51, 255);"><br style="color: rgb(51, 51, 255);"><span
 style="color: rgb(51, 51, 255);">        case TERMINAL:</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            print_terminal((TermAST *)ast);</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            break;</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">    }</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">}</span><br></pre>
<h1>Errors</h1>
Errors can be processed like this:<br>
<pre><span style="color: rgb(51, 51, 255);">for(ErrorList::iterator it = errors.begin(); it != errors.end(); ++it) {</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">    Error &amp;error = *it;</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">    cout &lt;&lt; "error at line " &lt;&lt; error.line() &lt;&lt; ", column " &lt;&lt; error.column() &lt;&lt; ": ";</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">    switch (error.type()) {</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        case LEXER_ERROR:</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            cout &lt;&lt; "invalid characters\n";</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            break;</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">        case PARSER_ERROR:</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            cout &lt;&lt; "syntax error\n";</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            break;</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">    }</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">    cout &lt;&lt; endl;</span><br
 style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">}</span><br></pre>
<h1>Why not Boost::Spirit?</h1>
Two reasons:<br>
<ul>
  <li>I find Boost::Spirit extremely complicated for my taste.</li>
  <li>all the template meta-programming makes compiling slow.<br>
  </li>
</ul>
<h1>How is whitespace parsed?</h1>
Whitespace parsing is done in-between each terminal declared in the
grammar. When the parser finds a terminal, it sets a flag to stop
parsing whitespace within the terminal, and thus terminals can contain
whitespace characters. The flag is reset after the terminal parsing
ends.<br>
<h1>Usage</h1>
Just include "parserlib.hpp" and "parserlib.cpp" in your project.<br>
The namespace is "parserlib" (of course).<br>
<br>
<br>
</body>
</html>
